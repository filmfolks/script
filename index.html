<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FILM FOLKS SCREENPLAY WRITER</title>
    <style>
        :root {
            --bg-color: #fff;
            --text-color: #000;
            --border-color: #ccc;
            --preview-bg: #f0f0f0;
            --font-size: 12pt; /* Default font size for zoom */
        }
        body.dark-mode {
            --bg-color: #1e1e1e;
            --text-color: #ddd;
            --border-color: #444;
            --preview-bg: #2a2a2a;
        }
        body { 
            font-family: 'Courier New', monospace; 
            display: flex; 
            height: 100vh; 
            margin: 0; 
            background: var(--bg-color); 
            color: var(--text-color); 
        }
        #editor { flex: 1.2; padding: 20px; border-right: 1px solid var(--border-color); } /* Increased horizontal space */
        #format-buttons { 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            width: 50px; 
            padding: 10px; 
            border-right: 1px solid var(--border-color); 
        }
        #format-buttons button { 
            margin: 5px 0; 
            padding: 3px; 
            width: 25px; 
            height: 25px; 
            font-size: 12pt; 
            font-weight: bold; 
            background: var(--bg-color); 
            color: var(--text-color); 
            border: 1px solid var(--border-color); 
            cursor: pointer; 
        }
        #preview { flex: 1; padding: 20px; overflow-y: auto; background: var(--preview-bg); }
        textarea { width: 100%; height: 80%; font-size: var(--font-size); border: 1px solid var(--border-color); resize: none; background: var(--bg-color); color: var(--text-color); } /* Increased vertical size, with zoom variable */
        input { width: 70%; margin-bottom: 10px; padding: 5px; font-size: 12pt; border: 1px solid var(--border-color); background: var(--bg-color); color: var(--text-color); display: inline-block; } /* Shortened fields */
        #title-form button { margin-left: 5px; padding: 5px 10px; vertical-align: top; position: relative; top: -10px; /* negative moves up */ } /* Set button close to fields, within editor frame */
        button { margin-top: 10px; padding: 3px 6px; margin-right: 5px; font-size: 10pt; } /* Reduced button size */
        .buttons-row { display: flex; align-items: center; flex-wrap: nowrap; } /* Keep buttons in one line */
        .scene-heading { font-weight: bold; text-transform: uppercase; margin: 1em 0; }
        .action { margin: 1em 0; }
        .character { text-transform: uppercase; margin: 2em 0 0 0; text-align: left; width: 60%; margin-left: 20%; }
        .dialogue { margin: 0 0 0 10%; width: 50%; }
        .parenthetical { margin: 0 0 0 15%; width: 45%; font-style: italic; }
        .transition { text-transform: uppercase; text-align: right; margin: 1em 0; }
        .note { font-style: italic; color: #666; margin: 1em 0; } /* Style for notes in preview */
        #output { max-width: 37em; margin: 0 auto; font-size: 12pt; line-height: 1.2; }
        #dark-mode-toggle, #fullscreen-toggle { cursor: pointer; font-size: 16px; background: none; border: none; }
        #exit-fullscreen { display: none; position: absolute; top: 10px; right: 10px; padding: 5px 10px; background: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); cursor: pointer; }
        body.fullscreen-mode #editor { flex: auto; width: 70%; margin: 0 auto; padding: 10px; } /* Reduced horizontal size, centered */
        body.fullscreen-mode #preview { display: none; }
        body.fullscreen-mode #format-buttons { position: absolute; top: 50%; right: 10px; transform: translateY(-50%); flex-direction: column; width: auto; padding: 0; border: none; background: transparent; } /* Vertical on right side */
        body.fullscreen-mode #format-buttons button { margin: 3px 0; }
        body.fullscreen-mode #exit-fullscreen { display: block; position: absolute; top: 10px; right: 10px; } /* Next to dark mode */
        body.fullscreen-mode textarea { height: 95%; }
        body.fullscreen-mode #title-form { display: none; }
        body.fullscreen-mode #title-display { display: block; position: absolute; top: 50%; left: 10px; transform: translateY(-50%); text-align: left; } /* Title and writer on left side */
        body.fullscreen-mode .buttons-row { display: none; }
        body.fullscreen-mode #auto-save-toggle { display: none; }
        body.fullscreen-mode #dark-mode-toggle { position: absolute; top: 10px; right: 60px; } /* Dark mode in right corner next to zoom and exit fullscreen */
        body.fullscreen-mode #fullscreen-toggle { display: none; } /* Hide fullscreen toggle in fullscreen */
        body.fullscreen-mode #zoom-in { display: block; position: absolute; top: 10px; right: 40px; padding: 5px 10px; background: var(--bg-color); color: var(--text-color); border: 1px solid var(--border-color); cursor: pointer; } /* Zoom button before exit fullscreen */
        #zoom-in { display: none; }
        #title-display { margin-top: 10px; font-size: 12pt; }
        #title-edit { margin-left: 5px; padding: 5px 10px; vertical-align: top; } /* Edit button close to display text, within editor frame */
        .title-controls { display: flex; align-items: center; margin-bottom: 10px; } /* Container for controls next to Save Title */
        .title-controls button { margin-left: 5px; padding: 5px; font-size: 16px; background: none; border: none; cursor: pointer; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
    <div id="editor">
        <div id="title-form">
            <input id="title" placeholder="Screenplay Title">
            <input id="writer" placeholder="Writer Name">
            <div class="title-controls">
                <button onclick="setTitle()">Save Title</button>
                <button id="dark-mode-toggle" onclick="toggleDarkMode()">☀️</button>
                <button onclick="zoomIn()">+</button>
                <button onclick="zoomOut()">-</button>
                <button onclick="resetZoom()">R</button>
                <button id="fullscreen-toggle" onclick="toggleFullscreen()">⛶</button>
            </div>
        </div>
        <div id="title-display" style="display: none;">
            <p id="display-title"></p>
            <p id="display-writer"></p>
            <button id="title-edit" onclick="editTitle()">Edit Title</button>
        </div>
        <textarea id="input" placeholder="Type Screenplay here... e.g., INT. HOUSE - DAY

SANTHOSH
Hello!"></textarea>
        <div class="buttons-row">
            <button onclick="saveFile()">Save as .fountain</button>
            <button onclick="printPDF()">Print PDF</button>
            <button onclick="previewFullscreen()">Preview Fullscreen</button>
            <button id="auto-save-toggle" onclick="toggleAutoSave()">Auto Save: Off</button>
        </div>
    </div>
    <div id="format-buttons">
        <button onclick="applyFormat('S')">S</button>
        <button onclick="applyFormat('A')">A</button>
        <button onclick="applyFormat('C')">C</button>
        <button onclick="applyFormat('D')">D</button>
        <button onclick="applyFormat('P')">P</button>
        <button onclick="applyFormat('T')">T</button>
        <button onclick="applyFormat('G')">G</button>
        <button onclick="applyFormat('N')">N</button>
    </div>
    <div id="preview">
        <h2>Screenplay Preview</h2>
        <div id="output"></div>
    </div>
    <button id="exit-fullscreen" onclick="toggleFullscreen()">□</button>
    <script>
        // Improved Fountain Parser with duplicate character merging, multi-line transition handling, and note handling
        const fountainParser = (function() {
            const rules = {
                scene_heading: /^((?:i(?:nt)?|e(?:xt)?|est|int\/ext|I\/E)[. ].+)|^(?:\.(?!.+ ))(.+)/i,
                action: /^[^\n]+$/,
                character: /^(?!\@)([A-Z0-9]{2,})(?:[\s^]+)?$/,
                dialogue: /^[^\n]+$/,
                parenthetical: /^\((.+)\)$/,
                transition: /^((?:fade |cut |smash cut |dissolve )?(?:in|out|to)| iris out).?$/i,
                note: /^Notes:-/i
            };
            function parse(text) {
                const lines = text.split(/\n/);
                let html = '';
                let state = 'action';
                let potentialTransition = '';
                let lastCharacter = '';
                lines.forEach(line => {
                    line = line.trim();
                    if (!line) return;
                    // Handle notes: Render in italics for preview
                    if (rules.note.test(line)) {
                        html += `<p class="note">${line}</p>`;
                        return; // Notes are not part of screenplay flow
                    }
                    // Handle duplicate characters
                    if (rules.character.test(line)) {
                        if (line === lastCharacter) {
                            return; // Skip duplicate
                        }
                        html += `<p class="character">${line}</p>`;
                        lastCharacter = line;
                        state = 'dialogue';
                        return;
                    }
                    lastCharacter = ''; // Reset after non-character line
                    // Detect and combine potential multi-line transitions
                    if (/^[A-Z\s:.]+$/.test(line) && state === 'action') {
                        potentialTransition += (potentialTransition ? ' ' : '') + line;
                        if (rules.transition.test(potentialTransition)) {
                            html += `<p class="transition">${potentialTransition}</p>`;
                            potentialTransition = '';
                            state = 'action';
                            return;
                        }
                    } else {
                        if (potentialTransition) {
                            html += `<p class="action">${potentialTransition}</p>`;
                            potentialTransition = '';
                        }
                    }
                    if (rules.scene_heading.test(line)) {
                        html += `<p class="scene-heading">${line}</p>`;
                        state = 'action';
                    } else if (rules.transition.test(line)) {
                        html += `<p class="transition">${line}</p>`;
                        state = 'action';
                    } else if (state === 'dialogue' && rules.parenthetical.test(line)) {
                        html += `<p class="parenthetical">${line}</p>`;
                    } else if (state === 'dialogue') {
                        html += `<p class="dialogue">${line}</p>`;
                    } else {
                        html += `<p class="action">${line}</p>`;
                        state = 'action';
                    }
                });
                if (potentialTransition) {
                    html += `<p class="action">${potentialTransition}</p>`;
                }
                return { html: { script: html } };
            }
            return { parse: parse };
        })();
        const input = document.getElementById('input');
        const output = document.getElementById('output');
        const toggleButton = document.getElementById('dark-mode-toggle');
        const autoSaveButton = document.getElementById('auto-save-toggle');
        const fullscreenToggle = document.getElementById('fullscreen-toggle');
        const exitFullscreen = document.getElementById('exit-fullscreen');
        const titleInput = document.getElementById('title');
        const writerInput = document.getElementById('writer');
        const titleForm = document.getElementById('title-form');
        const titleDisplay = document.getElementById('title-display');
        const displayTitle = document.getElementById('display-title');
        const displayWriter = document.getElementById('display-writer');
        let autoSaveInterval = null;
        let isAutoSaveOn = false;
        let isFullscreen = false;
        let currentFontSize = 12; // Initial font size in pt
        function updatePreview() {
            if (input.value.trim() === '') {
                output.innerHTML = '<p>After you type on the left, the preview will appear here.</p>';
                return;
            }
            const result = fountainParser.parse(input.value);
            if (result && result.html && result.html.script) {
                output.innerHTML = result.html.script;
            } else {
                output.innerHTML = '<p>Error parsing. Check syntax.</p>';
            }
        }
        input.addEventListener('input', updatePreview);
        updatePreview(); // Initial render
        // Function to apply formatting to the current/selected line
        function applyFormat(type) {
            const start = input.selectionStart;
            const end = input.selectionEnd;
            const text = input.value;
            const lines = text.split('\n');
            // Find the line index of the cursor/selection
            let charCount = 0;
            let lineIndex = -1;
            for (let i = 0; i < lines.length; i++) {
                charCount += lines[i].length + 1; // +1 for newline
                if (start < charCount) {
                    lineIndex = i;
                    break;
                }
            }
            if (lineIndex === -1) return; // No line found
            let line = lines[lineIndex].trim();
            // Apply format based on type
            switch (type) {
                case 'S': // Scene Heading: Uppercase and ensure format
                    line = line.toUpperCase();
                    if (!/^(INT\.|EXT\.|EST\.|INT\/EXT\.|I\/E\.)/i.test(line)) {
                        line = 'INT. ' + line; // Default to INT. if not specified
                    }
                    break;
                case 'A': // Action Description: Treat as general action (no change, default margin)
                case 'G': // General Text: Same as action, ensure left margin (no indent)
                    // No specific change; parser handles as action with left margin
                    break;
                case 'C': // Character: Uppercase
                    line = line.toUpperCase();
                    break;
                case 'D': // Dialogue: No specific change, but ensure it's after character (parser handles)
                    break;
                case 'P': // Parenthetical: Wrap in parentheses if not already
                    if (!/^\((.+\))$/.test(line)) {
                        line = '(' + line + ')';
                    }
                    break;
                case 'T': // Transition: Uppercase and add colon if missing
                    line = line.toUpperCase();
                    if (!line.endsWith(':')) {
                        line += ':';
                    }
                    break;
                case 'N': // Note: Prefix with "Notes:- " if not already
                    if (!/^Notes:-/i.test(line)) {
                        line = 'Notes:- ' + line;
                    }
                    break;
            }
            // Replace the line, preserving leading/trailing spaces
            const originalLine = lines[lineIndex];
            const leadingSpaces = originalLine.match(/^\s*/)[0];
            const trailingSpaces = originalLine.match(/\s*$/)[0];
            lines[lineIndex] = leadingSpaces + line + trailingSpaces;
            // Update textarea value and restore cursor
            input.value = lines.join('\n');
            input.selectionStart = input.selectionEnd = start; // Reset cursor
            updatePreview(); // Refresh preview
        }
        function saveFile(auto = false) {
            const blob = new Blob([input.value], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            if (auto) {
                const now = new Date();
                const timestamp = now.toISOString().replace(/T/, '_').replace(/:/g, '-').split('.')[0];
                a.download = `screenplay_${timestamp}.fountain`;
            } else {
                a.download = 'screenplay.fountain';
            }
            a.click();
            URL.revokeObjectURL(url);
        }
        function toggleAutoSave() {
            isAutoSaveOn = !isAutoSaveOn;
            autoSaveButton.textContent = `Auto Save: ${isAutoSaveOn ? 'On' : 'Off'}`;
            if (isAutoSaveOn) {
                autoSaveInterval = setInterval(() => saveFile(true), 120000); // Every 2 minutes
            } else {
                clearInterval(autoSaveInterval);
            }
        }
        function toggleFullscreen() {
            isFullscreen = !isFullscreen;
            document.body.classList.toggle('fullscreen-mode', isFullscreen);
            if (!isFullscreen) {
                fullscreenToggle.style.display = 'inline-block'; // Show fullscreen toggle in normal mode
            }
        }
        function setTitle() {
            const title = titleInput.value.trim();
            const writer = writerInput.value.trim();
            if (title || writer) {
                displayTitle.textContent = title ? `Title: ${title}` : '';
                displayWriter.textContent = writer ? `Writer: ${writer}` : '';
                titleForm.style.display = 'none';
                titleDisplay.style.display = 'block';
            }
        }
        function editTitle() {
            titleForm.style.display = 'block';
            titleDisplay.style.display = 'none';
        }
        // Zoom function (increases font size by 2pt each time, up to a max)
        function zoomIn() {
            currentFontSize += 2;
            if (currentFontSize > 24) currentFontSize = 24; // Max size
            document.documentElement.style.setProperty('--font-size', `${currentFontSize}pt`);
        }
        function zoomOut() {
            currentFontSize -= 2;
            if (currentFontSize < 8) currentFontSize = 8; // Min size
            document.documentElement.style.setProperty('--font-size', `${currentFontSize}pt`);
        }
        function resetZoom() {
            currentFontSize = 12;
            document.documentElement.style.setProperty('--font-size', `${currentFontSize}pt`);
        }
        // New function for full-screen preview of formatted screenplay
        function previewFullscreen() {
            const previewElement = document.getElementById('preview');
            if (previewElement.requestFullscreen) {
                previewElement.requestFullscreen();
            } else if (previewElement.mozRequestFullScreen) { /* Firefox */
                previewElement.mozRequestFullScreen();
            } else if (previewElement.webkitRequestFullscreen) { /* Chrome, Safari & Opera */
                previewElement.webkitRequestFullscreen();
            } else if (previewElement.msRequestFullscreen) { /* IE/Edge */
                previewElement.msRequestFullscreen();
            }
        }
        function generatePDF(forPrint = false) {
            if (!window.jspdf) {
                alert('jsPDF failed to load. Check your internet or try a different browser.');
                return;
            }
            if (output.innerHTML.trim() === '' || output.innerHTML === '<p>After you type on the left, the preview will appear here.</p>') {
                alert('No content to process. Add screenplay text first.');
                return;
            }
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'pt', format: 'a4', orientation: 'portrait' });
            doc.setFont('courier', 'normal');
            doc.setFontSize(12);
            // Add title page
            const title = (displayTitle.textContent.replace('Title: ', '') || titleInput.value.trim() || 'UNTITLED SCREENPLAY').toUpperCase();
            const writer = displayWriter.textContent.replace('Writer: ', '') || writerInput.value.trim() || 'Unknown Writer';
            doc.setFontSize(24);
            doc.setFont('courier', 'bold');
            doc.text(title, 297.5, 421, { align: 'center' }); // Center on A4
            doc.setFontSize(12);
            doc.setFont('courier', 'normal');
            doc.text('Written by', 297.5, 500, { align: 'center' });
            doc.text(writer, 297.5, 520, { align: 'center' });
            doc.addPage(); // Start screenplay on next page
            // Add screenplay content (skip notes)
            const elements = output.querySelectorAll('p:not(.note)');
            let y = 72; // Starting Y (1 inch margin)
            const pageWidth = 595; // A4 width in pt
            const pageHeight = 842; // A4 height in pt
            const leftMargin = 108; // 1.5 inch for action
            const rightMargin = pageWidth - 72; // 1 inch right
            const lineHeight = 12; // Standard screenplay line height
            elements.forEach(el => {
                let text = el.textContent.trim().replace(/\s+/g, ' '); // Clean extra spaces
                let x = leftMargin;
                const className = el.className;
                // Reset font before each element
                doc.setFont('courier', 'normal');
                // Apply styles and positioning
                if (className === 'scene-heading') {
                    doc.setFont('courier', 'bold');
                    text = text.toUpperCase(); // Force uppercase to match preview
                    x = leftMargin;
                    y += lineHeight; // Extra space above scenes
                } else if (className === 'character') {
                    x = leftMargin + 108; // 2.5 inch indent
                    y += lineHeight; // Space above character
                } else if (className === 'dialogue') {
                    x = leftMargin + 72; // 2 inch indent
                } else if (className === 'parenthetical') {
                    x = leftMargin + 90; // 2.2 inch indent
                    doc.setFont('courier', 'italic');
                } else if (className === 'transition') {
                    x = rightMargin - doc.getTextWidth(text); // Right-align
                    y += lineHeight; // Extra space
                } else {
                    x = leftMargin;
                }
                // Split long lines, but avoid over-splitting short ones
                const maxWidth = rightMargin - x - 36;
                const lines = text.length < 20 ? [text] : doc.splitTextToSize(text, maxWidth);
                lines.forEach(line => {
                    if (y + lineHeight > pageHeight - 72) {
                        doc.addPage();
                        y = 72;
                    }
                    doc.text(line, x, y);
                    y += lineHeight;
                });
                // Reset font after element and add spacing
                doc.setFont('courier', 'normal');
                y += lineHeight / 2; // Inter-element spacing
            });
            if (forPrint) {
                doc.autoPrint({ variant: 'non-conform' });
                window.open(doc.output('bloburl'), '_blank');
            } else {
                try {
                    const filename = `${title}.pdf`;
                    doc.save(filename);
                } catch (error) {
                    console.error('PDF save failed:', error);
                    alert('Save failed. Check console or try another browser.');
                    const blob = doc.output('blob');
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${title}.pdf`;
                    a.click();
                    URL.revokeObjectURL(url);
                }
            }
        }
        function printPDF() {
            generatePDF(true);
        }
        // Dark Mode Toggle
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            toggleButton.textContent = isDark ? '☀️' : '🌙';
            localStorage.setItem('darkMode', isDark ? 'enabled' : 'disabled');
        }
        // Load saved dark mode preference
        if (localStorage.getItem('darkMode') === 'enabled') {
            toggleDarkMode();
        } else {
            toggleButton.textContent = '🌙';
        }
        // Debug: Log if parser and jsPDF are ready
        document.addEventListener('DOMContentLoaded', () => {
            if (window.jspdf) {
                console.log('jsPDF loaded successfully.');
            } else {
                console.error('jsPDF failed to load. Check CDN.');
            }
            console.log('Fountain parser loaded and ready.');
        });
    </script>
</body>
</html>
